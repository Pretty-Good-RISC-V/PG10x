//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a87)
//
// On Sat Apr 23 20:25:59 PDT 2022
//
//
// Ports:
// Name                         I/O  size props
// RDY_memoryServer_request_put   O     1
// memoryServer_response_get      O     8 reg
// RDY_memoryServer_response_get  O     1
// get_tx_get                     O     1 reg
// RDY_get_tx_get                 O     1
// RDY_put_rx_put                 O     1
// CLK                            I     1 clock
// CLK_GATE                       I     1
// RST_N                          I     1 reset
// memoryServer_request_put       I    14 reg
// put_rx_put                     I     1 reg
// EN_memoryServer_request_put    I     1
// EN_put_rx_put                  I     1
// EN_memoryServer_response_get   I     1
// EN_get_tx_get                  I     1 unused
//
// Combinational paths from inputs to outputs:
//   CLK_GATE -> RDY_memoryServer_request_put
//   CLK_GATE -> RDY_memoryServer_response_get
//   CLK_GATE -> RDY_get_tx_get
//   CLK_GATE -> RDY_put_rx_put
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkUART(CLK,
	      CLK_GATE,
	      RST_N,

	      memoryServer_request_put,
	      EN_memoryServer_request_put,
	      RDY_memoryServer_request_put,

	      EN_memoryServer_response_get,
	      memoryServer_response_get,
	      RDY_memoryServer_response_get,

	      EN_get_tx_get,
	      get_tx_get,
	      RDY_get_tx_get,

	      put_rx_put,
	      EN_put_rx_put,
	      RDY_put_rx_put);
  input  CLK;
  input  CLK_GATE;
  input  RST_N;

  // action method memoryServer_request_put
  input  [13 : 0] memoryServer_request_put;
  input  EN_memoryServer_request_put;
  output RDY_memoryServer_request_put;

  // actionvalue method memoryServer_response_get
  input  EN_memoryServer_response_get;
  output [7 : 0] memoryServer_response_get;
  output RDY_memoryServer_response_get;

  // actionvalue method get_tx_get
  input  EN_get_tx_get;
  output get_tx_get;
  output RDY_get_tx_get;

  // action method put_rx_put
  input  put_rx_put;
  input  EN_put_rx_put;
  output RDY_put_rx_put;

  // signals for module outputs
  wire [7 : 0] memoryServer_response_get;
  wire RDY_get_tx_get,
       RDY_memoryServer_request_put,
       RDY_memoryServer_response_get,
       RDY_put_rx_put,
       get_tx_get;

  // inlined wires
  wire baudGenerator_baudRateX16$whas, baudGenerator_baudRateX2$whas;

  // register rx
  reg rx;
  wire rx$D_IN, rx$EN;

  // ports of submodule baudGenerator_baudRateX2Counter
  wire [2 : 0] baudGenerator_baudRateX2Counter$DATA_A,
	       baudGenerator_baudRateX2Counter$DATA_B,
	       baudGenerator_baudRateX2Counter$DATA_C,
	       baudGenerator_baudRateX2Counter$DATA_F,
	       baudGenerator_baudRateX2Counter$Q_OUT;
  wire baudGenerator_baudRateX2Counter$ADDA,
       baudGenerator_baudRateX2Counter$ADDB,
       baudGenerator_baudRateX2Counter$SETC,
       baudGenerator_baudRateX2Counter$SETF;

  // ports of submodule baudGenerator_clockCounter
  wire [6 : 0] baudGenerator_clockCounter$DATA_A,
	       baudGenerator_clockCounter$DATA_B,
	       baudGenerator_clockCounter$DATA_C,
	       baudGenerator_clockCounter$DATA_F,
	       baudGenerator_clockCounter$Q_OUT;
  wire baudGenerator_clockCounter$ADDA,
       baudGenerator_clockCounter$ADDB,
       baudGenerator_clockCounter$SETC,
       baudGenerator_clockCounter$SETF;

  // ports of submodule requests
  wire [13 : 0] requests$D_IN, requests$D_OUT;
  wire requests$CLR,
       requests$DEQ,
       requests$EMPTY_N,
       requests$ENQ,
       requests$FULL_N;

  // ports of submodule responses
  wire [7 : 0] responses$D_IN, responses$D_OUT;
  wire responses$CLR, responses$DEQ, responses$EMPTY_N, responses$ENQ;

  // ports of submodule transmitter
  wire [7 : 0] transmitter$putData_put;
  wire transmitter$EN_get_tx_get,
       transmitter$EN_putBaudX2Ticked_put,
       transmitter$EN_putData_put,
       transmitter$RDY_putBaudX2Ticked_put,
       transmitter$RDY_putData_put,
       transmitter$get_tx_get,
       transmitter$putBaudX2Ticked_put;

  // remaining internal signals
  wire requests_i_notEmpty__0_AND_NOT_requests_first__ETC___d20;

  // action method memoryServer_request_put
  assign RDY_memoryServer_request_put = CLK_GATE && requests$FULL_N ;

  // actionvalue method memoryServer_response_get
  assign memoryServer_response_get = responses$D_OUT ;
  assign RDY_memoryServer_response_get = CLK_GATE && responses$EMPTY_N ;

  // actionvalue method get_tx_get
  assign get_tx_get = transmitter$get_tx_get ;
  assign RDY_get_tx_get = CLK_GATE ;

  // action method put_rx_put
  assign RDY_put_rx_put = CLK_GATE ;

  // submodule baudGenerator_baudRateX2Counter
  Counter #(.width(32'd3),
	    .init(3'd0)) baudGenerator_baudRateX2Counter(.CLK(CLK),
							 .RST(RST_N),
							 .DATA_A(baudGenerator_baudRateX2Counter$DATA_A),
							 .DATA_B(baudGenerator_baudRateX2Counter$DATA_B),
							 .DATA_C(baudGenerator_baudRateX2Counter$DATA_C),
							 .DATA_F(baudGenerator_baudRateX2Counter$DATA_F),
							 .ADDA(baudGenerator_baudRateX2Counter$ADDA),
							 .ADDB(baudGenerator_baudRateX2Counter$ADDB),
							 .SETC(baudGenerator_baudRateX2Counter$SETC),
							 .SETF(baudGenerator_baudRateX2Counter$SETF),
							 .Q_OUT(baudGenerator_baudRateX2Counter$Q_OUT));

  // submodule baudGenerator_clockCounter
  Counter #(.width(32'd7), .init(7'd0)) baudGenerator_clockCounter(.CLK(CLK),
								   .RST(RST_N),
								   .DATA_A(baudGenerator_clockCounter$DATA_A),
								   .DATA_B(baudGenerator_clockCounter$DATA_B),
								   .DATA_C(baudGenerator_clockCounter$DATA_C),
								   .DATA_F(baudGenerator_clockCounter$DATA_F),
								   .ADDA(baudGenerator_clockCounter$ADDA),
								   .ADDB(baudGenerator_clockCounter$ADDB),
								   .SETC(baudGenerator_clockCounter$SETC),
								   .SETF(baudGenerator_clockCounter$SETF),
								   .Q_OUT(baudGenerator_clockCounter$Q_OUT));

  // submodule requests
  FIFO2 #(.width(32'd14), .guarded(1'd1)) requests(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(requests$D_IN),
						   .ENQ(requests$ENQ),
						   .DEQ(requests$DEQ),
						   .CLR(requests$CLR),
						   .D_OUT(requests$D_OUT),
						   .FULL_N(requests$FULL_N),
						   .EMPTY_N(requests$EMPTY_N));

  // submodule responses
  FIFO2 #(.width(32'd8), .guarded(1'd1)) responses(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(responses$D_IN),
						   .ENQ(responses$ENQ),
						   .DEQ(responses$DEQ),
						   .CLR(responses$CLR),
						   .D_OUT(responses$D_OUT),
						   .FULL_N(),
						   .EMPTY_N(responses$EMPTY_N));

  // submodule transmitter
  mkTransmitter transmitter(.CLK(CLK),
			    .CLK_GATE(CLK_GATE),
			    .RST_N(RST_N),
			    .putBaudX2Ticked_put(transmitter$putBaudX2Ticked_put),
			    .putData_put(transmitter$putData_put),
			    .EN_putData_put(transmitter$EN_putData_put),
			    .EN_putBaudX2Ticked_put(transmitter$EN_putBaudX2Ticked_put),
			    .EN_get_tx_get(transmitter$EN_get_tx_get),
			    .RDY_putData_put(transmitter$RDY_putData_put),
			    .RDY_putBaudX2Ticked_put(transmitter$RDY_putBaudX2Ticked_put),
			    .get_tx_get(transmitter$get_tx_get),
			    .RDY_get_tx_get());

  // inlined wires
  assign baudGenerator_baudRateX2$whas =
	     CLK_GATE && baudGenerator_baudRateX2Counter$Q_OUT == 3'd0 &&
	     baudGenerator_baudRateX16$whas ;
  assign baudGenerator_baudRateX16$whas =
	     CLK_GATE && baudGenerator_clockCounter$Q_OUT == 7'd104 ;

  // register rx
  assign rx$D_IN = put_rx_put ;
  assign rx$EN = EN_put_rx_put ;

  // submodule baudGenerator_baudRateX2Counter
  assign baudGenerator_baudRateX2Counter$DATA_A = 3'd1 ;
  assign baudGenerator_baudRateX2Counter$DATA_B = 3'h0 ;
  assign baudGenerator_baudRateX2Counter$DATA_C = 3'h0 ;
  assign baudGenerator_baudRateX2Counter$DATA_F = 3'h0 ;
  assign baudGenerator_baudRateX2Counter$ADDA =
	     CLK_GATE && baudGenerator_baudRateX16$whas ;
  assign baudGenerator_baudRateX2Counter$ADDB = 1'b0 ;
  assign baudGenerator_baudRateX2Counter$SETC = 1'b0 ;
  assign baudGenerator_baudRateX2Counter$SETF = 1'b0 ;

  // submodule baudGenerator_clockCounter
  assign baudGenerator_clockCounter$DATA_A = 7'd1 ;
  assign baudGenerator_clockCounter$DATA_B = 7'h0 ;
  assign baudGenerator_clockCounter$DATA_C = 7'h0 ;
  assign baudGenerator_clockCounter$DATA_F = 7'h0 ;
  assign baudGenerator_clockCounter$ADDA = CLK_GATE ;
  assign baudGenerator_clockCounter$ADDB = 1'b0 ;
  assign baudGenerator_clockCounter$SETC = 1'b0 ;
  assign baudGenerator_clockCounter$SETF = 1'b0 ;

  // submodule requests
  assign requests$D_IN = memoryServer_request_put ;
  assign requests$ENQ = EN_memoryServer_request_put ;
  assign requests$DEQ =
	     CLK_GATE &&
	     requests_i_notEmpty__0_AND_NOT_requests_first__ETC___d20 ;
  assign requests$CLR = 1'b0 ;

  // submodule responses
  assign responses$D_IN = 8'h0 ;
  assign responses$ENQ = 1'b0 ;
  assign responses$DEQ = EN_memoryServer_response_get ;
  assign responses$CLR = 1'b0 ;

  // submodule transmitter
  assign transmitter$putBaudX2Ticked_put = baudGenerator_baudRateX2$whas ;
  assign transmitter$putData_put = requests$D_OUT[7:0] ;
  assign transmitter$EN_putData_put =
	     CLK_GATE &&
	     requests_i_notEmpty__0_AND_NOT_requests_first__ETC___d20 &&
	     requests$D_OUT[13] &&
	     requests$D_OUT[11:8] == 4'd0 ;
  assign transmitter$EN_putBaudX2Ticked_put =
	     transmitter$RDY_putBaudX2Ticked_put && CLK_GATE ;
  assign transmitter$EN_get_tx_get = EN_get_tx_get ;

  // remaining internal signals
  assign requests_i_notEmpty__0_AND_NOT_requests_first__ETC___d20 =
	     requests$EMPTY_N &&
	     (!requests$D_OUT[13] || requests$D_OUT[11:8] != 4'd0 ||
	      transmitter$RDY_putData_put) ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rx <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (rx$EN) rx <= `BSV_ASSIGNMENT_DELAY rx$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rx = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkUART

